* +\(void\)load方法比main函数先调用[^要手动释放内存]，打印就能判断先后[^load方法，每次程序一启动,就会把所有的类加载进内存，类方法，静态变量等等所有类的内容],实际上UIApplication对象是在main函数里创建的，不是在load方法里创建的。

[^一调用init方法就会调用+ (void)initialize{
if (self == [XMGArenaNavViewController class]),初始化对象的时候调用，继承3层调用3次，避免错误，判断类型]

* 禁止别人第二次调用alloc方法，一调用就崩掉，断言或者异常
* 提供一个方法给外界获取单例

```
@implementation Person
// 程序启动时候创建对象
// 静态变量
static Person *_instance = nil;

// 作用:加载类
// 什么调用:每次程序一启动,就会把所有的类加载进内存
+ (void)load
{
NSLog(@"%s",__func__);

}

### 01-项目中常见的文件(LaunchScreen)
LaunchScreen原理:会自动加载LaunchScreen是因为在Target当中,指定了Launch Screen file,如果没有指定的话,就不会去加载LaunchScreen作为启动界面.
如果没有设置启动图片,模拟器默认的尺寸大小是4s的尺寸大小.(可以打印屏幕尺寸验证.)
模拟器默认的尺寸是由启动界面决定的.它的底层实现其实把LaunchScreen上的东西,生成了一张图片,然后把这张图片设为程序的启动图片.

>可以进入沙盒当中查看, 查看方法,找到应用程序根目录.获取方法: NSLog(@"%@",NSHomeDirectory());打印出来,后前往文件夹.找到Library->Caches->Snapshots目录下面.最后一层就是程序自动生成的图片.
		

02-项目中常见的文件(info.plist)
	
	Supporting file一般都是放些资源文件,像一些plist这些等.
	xcode5当中也有info.plist,只不过它的名字很长.是工程的名称.
	在xcode5当中,会自动生成一个pch文件,在Xcode6当中不会帮我们生成PCH文件.
	
	info.plist当中保存着整个应用当中基本的配置.它是一个字典.查看它的类型.
	这个当中,主要掌握三个Key,
	Bundle Name:应用程序的名称.
	Bundle version string,short:应用程序的版本.在开发当中都是迭代开发.苹果要求下一次提交的版本必须得要比上一次提交的版本要高.
	
	Bundle Version:应用程序编译的版本.
	Bundle identifier:应用程序标识符.保证应用程序的唯一性, 
					   如果两个应用同一个标识符, 那么之前的那个应用会被干掉.
					   作用:上传到AppStore的时候必须得要有标识符.
					   		当做推送的时候也必须得要Bundle identifier.
	Targets对应者info.plist.文件.	
	
			

			
			
07-UIWindow
		
	UIWindow是一种特殊的UIView，通常在一个app中至少有一个UIWindow
	iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的view，
	最后将控制器的view添加到UIWindow上，于是控制器的view就显示在屏幕上了
	一个iOS程序之所以能显示到屏幕上，完全是因为它有UIWindow
	
	在加载info.plist,判断下是否指定main,如果指定了,就会去加载StoryBoard.
		1.创建一个窗口
		2.加载MainStoryBoard,初始化一个控制器.
		3.把初始化出来的控制器设置为窗口的根控制器.让窗口显示到屏幕上.

	如果没有指定Mian话, 那这个时候就需要我们手动的去创建窗口.
	当info.plist文件没有找到的时候,那么程序就加载完毕,那么在程序加载完毕时要自己手动去创建窗口.
	
	在开发当中,通常都是手动去创建窗口.
	
	1.创建窗口,要有窗口显示,必须要有强引用.窗口也是控件,要想展示出来.必须得要有尺寸.
	  	self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
	2.创建控制器
	    会把控制器的View添加到窗口上.并且有一个旋转的功能.
	    UIViewController *vc = [[UIViewController alloc] init];
	    vc.view.backgroundColor = [UIColor redColor];
	   
	3.设置控制器为窗口的根控制器
		self.window.rootViewController = vc;
	4.显示窗口
		[self.window makeKeyAndVisible];
	
	
	
	在设置rootViewController的时候,会把控制器的View添加到窗口上面.
	[self.window makeKeyAndVisible]的底层实现:
		1.让窗口成为显示状态.
		  窗口默认是隐藏的.hidden = yes.
		  底层做的事件就是:
		   self.window.hidden = NO;
		   
		2.把当前窗口设置成应用程序的主窗口
		   application.keyWindow获得应用程序的主窗口.
	
	
	
	在程序当中,状态栏和键盘,它都属性是一个窗口.可以通过打印的方式来验证.
	设置window的层级.UIWindowLevelNormal它是一个CGFloat类型.
	self.window.windowLevel = UIWindowLevelNormal
	UIWindowLevelNormal < UIWindowLevelStatusBar < UIWindowLevelAlert
	
	
	
08-从StoryBoard加载控制器

    1.创建窗口
    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
    2.加载控制器
    从StoryBoard当中加载控制器
    UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@"Main" bundle:nil];
    加载剪头指向的控制器
    UIViewController *vc = [storyBoard instantiateInitialViewController];
    3.设置窗口根控制器
    self.window.rootViewController = vc;
    4.显示窗口
    [self.window makeKeyAndVisible];
    
    
    加载控制器的两种方式
    
    0.加载指定的StoryBoard.
    UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@"Main" bundle:nil];
    1.加载箭头所指向的控制器.
    UIViewController *vc = [storyBoard instantiateInitialViewController];
    2.加载指定标识的控制器.
     UIViewController *vc = [storyBoard 		
     						  instantiateViewControllerWithIdentifier:@"idCongtroler"];
     						  
    
	
			
	
09-能过Xib加载控制器的View

	加载的步骤为:
	1.创建Xib
	2.往xib当中拖入一个View.
	3.设置Xib的file's owner类型为要设置的那个控制器.
	4.把View与file's owner连线.	(注意, 只有设置了file's owner类型才能够进行拖线.)
	
	initWithNibName:为要加载的Xib的名称.
	 MyViewController *vc = [[MyViewController alloc] initWithNibName:@"VC" bundle:nil];
	
	

	


		

	
			
	
	
		
				   		
					   		
	
	
	
	