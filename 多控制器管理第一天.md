### 01-项目中常见的文件(LaunchScreen)
LaunchScreen原理:会自动加载LaunchScreen是因为在Target当中,指定了Launch Screen file,如果没有指定的话,就不会去加载LaunchScreen作为启动界面.
如果没有设置启动图片,模拟器默认的尺寸大小是4s的尺寸大小.(可以打印屏幕尺寸验证.)
模拟器默认的尺寸是由启动界面决定的.它的底层实现其实把LaunchScreen上的东西,生成了一张图片,然后把这张图片设为程序的启动图片.

>可以进入沙盒当中查看, 查看方法,找到应用程序根目录.获取方法: NSLog(@"%@",NSHomeDirectory());打印出来,后前往文件夹.找到Library->Caches->Snapshots目录下面.最后一层就是程序自动生成的图片.
		

02-项目中常见的文件(info.plist)
	
	Supporting file一般都是放些资源文件,像一些plist这些等.
	xcode5当中也有info.plist,只不过它的名字很长.是工程的名称.
	在xcode5当中,会自动生成一个pch文件,在Xcode6当中不会帮我们生成PCH文件.
	
	info.plist当中保存着整个应用当中基本的配置.它是一个字典.查看它的类型.
	这个当中,主要掌握三个Key,
	Bundle Name:应用程序的名称.
	Bundle version string,short:应用程序的版本.在开发当中都是迭代开发.苹果要求下一次提交的版本必须得要比上一次提交的版本要高.
	
	Bundle Version:应用程序编译的版本.
	Bundle identifier:应用程序标识符.保证应用程序的唯一性, 
					   如果两个应用同一个标识符, 那么之前的那个应用会被干掉.
					   作用:上传到AppStore的时候必须得要有标识符.
					   		当做推送的时候也必须得要Bundle identifier.
	Targets对应者info.plist.文件.	
	
			

04-UIApplication单例.

	什么是UIApplication?
		UIApplication对象是应用程序的象征.
		每一个应用都有自己的UIApplication对象,这个对象是系统自动帮我们创建的, 它是一个单例对象.
		一个iOS程序启动后创建的第一个对象就是UIApplication对象
		我们只能通过[UIApplication sharedApplication]获得这个单例对象,不能够手动去创建它.

		
	UIApplication作用?
		利用UIApplication对象，能进行一些应用级别的操作.
		可以设置应用程序图标右上角的红色提醒数字
		设置联网指示器的可见性
		可以设置应用程序的状态栏
		进行应用之间的跳转.
		
	模仿UIApplication单例.
	要求:程序一启动就创建创建对象.
		创建的对象只能通过share的方式获取对象.
		不能够进行alloc 操作,当执行alloc时, 程序发生崩溃
		
		1.程序一启动的时候就创建对象.
		当类被加载到内存的时候就会调用load的方法,它会比main优先调用
		static Persion *_instance;
		+(void)load{
		    
		    想要保存创建的对象, 要用成员属性,但是现在是类方法, 没有办法访问成员属性.
		    所以搞了一个static的静态变量进行保存
		    创建对象
		    _instance = [[self alloc] init];
		}
		
		2.保证调用alloc时会产生异常.
		重写系统的是alloc方法
		+(instancetype)alloc{
			当调用alloc方法时,先查看一下_instance有没有值,如果已经有值的话,直接抛出异常.
		    if(_instance){
		       NSException *exception = [NSException exceptionWithName:
		                              @"NSInternalInconsistencyException"
		                                                     reason:
		                          @"There can only be one Persion instance." userInfo:nil];
		        抛出异常
		        [exception raise];
		    }
		    
		    保持系统的做法.
		   return [super alloc];
		}
		
		3.通过share方式获取对象
			+(instancetype)sharePersion{
				return _instance
			}
			
			
			
05-UIApplication功能

	1.设置应用提醒数字
	    获取UIApplication对象
	    UIApplication *ap = [UIApplication sharedApplication];
	    
	    在设置之前, 要注册一个通知,从ios8之后,都要先注册一个通知对象.才能够接收到提醒.
	    UIUserNotificationSettings *notice = [UIUserNotificationSettings   
	    	settingsForTypes:UIUserNotificationTypeBadge categories:nil];
	    注册通知对象
	    [ap registerUserNotificationSettings:notice];
	    设置提醒数字
	    ap.applicationIconBadgeNumber = 10;
	2.设置连网状态
	   ap.networkActivityIndicatorVisible = YES;
	3.设置状态栏
		应用程序的状态栏,默认是交给控制器来管理的.
		控制器提供的方法,可以直接重写这个方法
		在控制器当中设置状态栏样式
		-(UIStatusBarStyle)preferredStatusBarStyle{
    		return UIStatusBarStyleLightContent;
    	}
    	
    	隐藏状态栏,通过控制器的方式.同样实现方法:
    	返回NO时为不隐藏
    	返回YES时为隐匿
    	-(BOOL)prefersStatusBarHidden{
    		return NO;
    	}
    	
    	通常在开发当中都是应用程序来管理状态栏的.来做统一管理,不然的话, 会有很多个控制器.会非常的麻烦.
    	想要让应用程序管理状态栏,要在info.plist当中进行配置,
    	添加一个key值:是最后一个,View controller-based status bar appearance
    	设置为NO.就是应用程序来管理了.
    	
    	通过UIApplication来管理状态.
    	1.获取UIApplication
    	UIApplication *ap = [UIApplication sharedApplication];
    	2.设置状态栏样式.
        ap.statusBarStyle = UIStatusBarStyleLightContent;
        3.设置状态的隐藏
        ap.statusBarHidden = YES;
		
    	
	4.跳转网页
		UIApplication *ap = [UIApplication sharedApplication];
		URL:协议头://域名
		应用程序通过协议头的类型,去打开相应的软件.
    	NSURL *url =[NSURL URLWithString:@"http://www.baidu.com"];
    	[ap openURL:url];


			
06-	UIApplication代理和程序的启动流程.

	所有的移动操作系统都有个致命的缺点：app很容易受到打扰。比如一个来电或者锁屏会导致app进入后台甚至被终止
	还有很多其它类似的情况会导致app受到干扰，在app受到干扰时，会产生一些系统事件，
	这时UIApplication会通知它的delegate对象，让delegate代理来处理这些系统事件
	
	delegate可处理的事件包括：
	应用程序的生命周期事件(如程序启动和关闭)
	系统事件(如来电)
	内存警告
	...
	
	UIApplication会在程序一启动时候创建一个遵守UIApplicationDelegate代理.
	这个就是我们程序一创建时的AppDelegate类.AppDelegate就是遵守了UIApplicationDelegate协议.
	在这个类中很定义很多监听系统事件的方法.同时也定义了一些应用程序的生命周期方法.
		
	主要方法有:
	
	 应用程序的生命周期
	 应用程序启动完成的时候调用
	- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
	    NSLog(@"%s",__func__);
	    return YES;
	}
	
	 当我们应用程序即将失去焦点的时候调用
	- (void)applicationWillResignActive:(UIApplication *)application {
	    NSLog(@"%s",__func__);
	}
	
	 当我们应用程序完全进入后台的时候调用
	- (void)applicationDidEnterBackground:(UIApplication *)application{
	   NSLog(@"%s",__func__);
	}
	
	 当我们应用程序即将进入前台的时候调用
	- (void)applicationWillEnterForeground:(UIApplication *)application {
	  NSLog(@"%s",__func__);}
	
	 当我们应用程序完全获取焦点的时候调用
	 只有当一个应用程序完全获取到焦点,才能与用户交互.
	- (void)applicationDidBecomeActive:(UIApplication *)application {
	    NSLog(@"%s",__func__);
	}
	
	 当我们应用程序即将关闭的时候调用
	- (void)applicationWillTerminate:(UIApplication *)application {
	   NSLog(@"%s",__func__);
	}

	2.应用程序的程动原理
		
		程序启动时执行main函数,在main函数当中有以下操作.
		int main(int argc, char * argv[]) {
		  @autoreleasepool {
        	第三个参数:UIApplication类名或者子类的名称 nil == @"UIApplication"
        	第四个参数:UIApplication的代理的代理名称
       		NSStringFromClass:把类名转化字符串
        	NSStringFromClass好处:1.有提示功能 2.避免输入错误
           return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    	  }
    
    	}
	
	底层原理为:
		1.根据principalClassName传递的类名创建UIApplication对象
		2.创建UIApplication代理对象,给UIApplication对象设置代理
		3.开启主运行事件循环,处理事件,保持程序一直运行.
		4.加载info.plist,判断下是否指定main,如果指定了,就会去加载StoryBoard.
			
			
			
07-UIWindow
		
	UIWindow是一种特殊的UIView，通常在一个app中至少有一个UIWindow
	iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的view，
	最后将控制器的view添加到UIWindow上，于是控制器的view就显示在屏幕上了
	一个iOS程序之所以能显示到屏幕上，完全是因为它有UIWindow
	
	在加载info.plist,判断下是否指定main,如果指定了,就会去加载StoryBoard.
		1.创建一个窗口
		2.加载MainStoryBoard,初始化一个控制器.
		3.把初始化出来的控制器设置为窗口的根控制器.让窗口显示到屏幕上.

	如果没有指定Mian话, 那这个时候就需要我们手动的去创建窗口.
	当info.plist文件没有找到的时候,那么程序就加载完毕,那么在程序加载完毕时要自己手动去创建窗口.
	
	在开发当中,通常都是手动去创建窗口.
	
	1.创建窗口,要有窗口显示,必须要有强引用.窗口也是控件,要想展示出来.必须得要有尺寸.
	  	self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
	2.创建控制器
	    会把控制器的View添加到窗口上.并且有一个旋转的功能.
	    UIViewController *vc = [[UIViewController alloc] init];
	    vc.view.backgroundColor = [UIColor redColor];
	   
	3.设置控制器为窗口的根控制器
		self.window.rootViewController = vc;
	4.显示窗口
		[self.window makeKeyAndVisible];
	
	
	
	在设置rootViewController的时候,会把控制器的View添加到窗口上面.
	[self.window makeKeyAndVisible]的底层实现:
		1.让窗口成为显示状态.
		  窗口默认是隐藏的.hidden = yes.
		  底层做的事件就是:
		   self.window.hidden = NO;
		   
		2.把当前窗口设置成应用程序的主窗口
		   application.keyWindow获得应用程序的主窗口.
	
	
	
	在程序当中,状态栏和键盘,它都属性是一个窗口.可以通过打印的方式来验证.
	设置window的层级.UIWindowLevelNormal它是一个CGFloat类型.
	self.window.windowLevel = UIWindowLevelNormal
	UIWindowLevelNormal < UIWindowLevelStatusBar < UIWindowLevelAlert
	
	
	
08-从StoryBoard加载控制器

    1.创建窗口
    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
    2.加载控制器
    从StoryBoard当中加载控制器
    UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@"Main" bundle:nil];
    加载剪头指向的控制器
    UIViewController *vc = [storyBoard instantiateInitialViewController];
    3.设置窗口根控制器
    self.window.rootViewController = vc;
    4.显示窗口
    [self.window makeKeyAndVisible];
    
    
    加载控制器的两种方式
    
    0.加载指定的StoryBoard.
    UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@"Main" bundle:nil];
    1.加载箭头所指向的控制器.
    UIViewController *vc = [storyBoard instantiateInitialViewController];
    2.加载指定标识的控制器.
     UIViewController *vc = [storyBoard 		
     						  instantiateViewControllerWithIdentifier:@"idCongtroler"];
     						  
    
	
			
	
09-能过Xib加载控制器的View

	加载的步骤为:
	1.创建Xib
	2.往xib当中拖入一个View.
	3.设置Xib的file's owner类型为要设置的那个控制器.
	4.把View与file's owner连线.	(注意, 只有设置了file's owner类型才能够进行拖线.)
	
	initWithNibName:为要加载的Xib的名称.
	 MyViewController *vc = [[MyViewController alloc] initWithNibName:@"VC" bundle:nil];
	
	

	


		

	
			
	
	
		
				   		
					   		
	
	
	
	